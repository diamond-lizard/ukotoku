#!/usr/bin/python3.6
#
# Convert files from audio formats to image formats and back.
#
#
##############################################################################
#
# Copyright (C) 2020 - Sergey Goldgaber
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
##############################################################################

# For command line argument processing:
import click

# For writing TIFF images:
import imageio

# For reading WAV files:
import wave

# For converting 1-dimensional WAV data to 2-dimensional numpy arrays
# Note: 2-dimensional numpy arrays are the only kind imageio will accept
import numpy

# For the ceil function
import math

# Regexes
import re

# To find out what the path of this script is
from pathlib import Path

# To check if a file exists with os.path.isfile()
import os


@click.command()
@click.argument('input_file',  nargs=1, required=True, metavar='INPUT')
@click.argument('output_file', nargs=1, required=True, metavar='OUTPUT')
@click.option("--channels",    required=False, type=click.INT,    help="Number of channels for the WAV.")
@click.option("--resolution",  required=False, type=click.STRING, help="x and y image resolution", metavar="WIDTHxHEIGHT or 'guess'")
@click.option("--sampwidth",   required=False, type=click.INT,    help="Sample width for the WAV.")
@click.option("--samprate",    required=False, type=click.INT,    help="Sample rate for the WAV.")
def ukotoku(input_file, output_file, channels, resolution, sampwidth, samprate):
    input_file_type = ukotoku_get_input_file_type(input_file)
    output_file_type = ukotoku_get_output_file_type(output_file)
    if input_file_type == 'wav':
        if output_file_type == 'tiff':
            ukotoku_wav2tiff(input_file, output_file, resolution)
    elif input_file_type == 'tiff':
        if output_file_type == 'wav':
            ukotoku_tiff2wav(input_file, output_file, channels, sampwidth, samprate)
    else:
        ukotoku_exiterr("Unexpected INPUT file type.")


# Exit after printing an error message to STDERR
def ukotoku_exiterr(message):
    ukotoku_printerr(message)
    exit(1)


# Expect image resolution in the form WIDTHxHEIGHT or 'guess'
def ukotoku_get_image_size_from_user(resolution):
    ukotoku_wav2tiff_validate_resolution(resolution)

    if resolution == 'guess':
        x = 'guess'
        y = 'guess'
    else:
        match = re.search('^(\d+)x(\d+)$', resolution)
        if match:
            x = int(match.group(1))
            y = int(match.group(2))
        else:
            ukotoku_exiterr("resolution must be in the form WIDTHxHEIGHT or 'guess'")
    return (x, y)


def ukotoku_get_output_file_type(output_file):
    # Make sure the output file type is allowed
    match = re.search('\.([^.]+)$', output_file)
    if match:
        output_file_extension = match.group(1)
    else:
        ukotoku_exiterr("The OUTPUT filename must have an extension, such as .wav or .tiff")

    valid_audio_extensions = [
        'wav',
        ]

    valid_image_extensions = [
        'tiff',
        ]

    if   output_file_extension.casefold() in (f.casefold() for f in valid_audio_extensions):
        return 'wav'
    elif output_file_extension.casefold() in (f.casefold() for f in valid_image_extensions):
        return 'tiff'
    else:
        valid_audio_extensions = ', '.join(valid_audio_extensions)
        valid_image_extensions = ', '.join(valid_image_extensions)
        message = "OUTPUT file extension must be one of: "
        message = message + valid_audio_extensions + valid_image_extensions
        ukotoku_exiterr(message)



def ukotoku_get_raw_wav(input_file):
    # Read file to get buffer
    ifile   = wave.open(input_file)
    samples = ifile.getnframes()
    raw_wav = ifile.readframes(samples)
    return raw_wav


# Decide on image resolution.
#
# We could choose anything, but have decided on a square
# that should fit at least as many elements as are contained in the
# one-dimensional WAV array
def ukotoku_guess_image_resolution(number_of_elements_in_wav):
    # We do the following to make the minimum sized square that will
    # fit the data:
    x = math.ceil(math.sqrt(number_of_elements_in_wav))
    y = x
    return (x,y)


# Print an error message to STDERR
def ukotoku_printerr(message):
    this_script = Path(__file__)
    message = f'{this_script}: Error: {message}'
    click.echo(message=message, err=True)


def ukotoku_tiff2wav(input_file, output_file, channels, sampwidth, samprate):
    ukotoku_tiff2wav_validate_output_file(output_file)

    # Make sure OUTPUT does not exist
    output_file_exists = os.path.isfile(output_file)
    if output_file_exists:
        ukotoku_exiterr(f"OUTPUT file '{output_file}' already exists.")
    tiff_data = imageio.imread(input_file)

    # Change the image array from 2D to 1D
    tiff_data = tiff_data.reshape(tiff_data.size,order='C')

    wav_output_file = wave.open(output_file, 'w')
    wav_output_file.setnchannels(channels)
    wav_output_file.setsampwidth(sampwidth)
    wav_output_file.setframerate(samprate)

    wav_output_file.writeframesraw(tiff_data)


def ukotoku_tiff2wav_validate_output_file(output_file):
    # Make sure the OUTPUT filename has a valid extension
    match = re.search('\.([^.]+)$', output_file)
    if match:
        output_file_extension = match.group(1)
    else:
        ukotoku_exiterr("The INPUT filename must have an extension, such as .wav or .tiff")

    valid_audio_extensions = [
        'wav',
        ]

    valid_image_extensions = [
        'tiff',
        ]

    if   output_file_extension.casefold() in (f.casefold() for f in valid_audio_extensions):
        pass
    elif output_file_extension.casefold() in (f.casefold() for f in valid_image_extensions):
        pass
    else:
        valid_audio_extensions = ', '.join(valid_audio_extensions)
        valid_image_extensions = ', '.join(valid_image_extensions)
        message = "OUTPUT file extension must be one of: "
        message = message + valid_audio_extensions + valid_image_extensions
        ukotoku_exiterr(message)


def ukotoku_wav2tiff(input_file, output_file, resolution):
    ukotoku_wav2tiff_validate_output_file(output_file)

    x, y = ukotoku_get_image_size_from_user(resolution)

    raw_wav = ukotoku_get_raw_wav(input_file)

    # Convert raw WAV to a one-dimensional, 16-bit numpy array
    unpadded_wav_data_1d = numpy.frombuffer(raw_wav, dtype=numpy.int16)
    source_shape = unpadded_wav_data_1d.shape
    if len(source_shape) == 1:
        ukotoku_wav2tiff_pad_and_write(
            output_file,
            unpadded_wav_data_1d,
            source_shape,
            x,
            y)
    else:
        ukotoku_exiterr("Error: Unexpected WAV data format")


def ukotoku_wav2tiff_get_wav_data_2d(
    unpadded_wav_data_1d,
    x,
    y,
    source_shape):
    if x * y == unpadded_wav_data_1d.size:
        # No padding is necessary
        wav_data_2d = numpy.reshape(unpadded_wav_data_1d, (y,x), order='C')
    else:
        # Padding is necessary

        # Figure out how much to pad the source array to the right
        # to make it fit the destination array shape exactly
        right_padding_len = numpy.prod((x,y)) - numpy.prod(source_shape)

        # We now have enough information to pad
        pad_width = (0,right_padding_len)
        padded_wav_data_1d = numpy.pad(unpadded_wav_data_1d,
                                        pad_width,
                                        mode='constant',
                                        constant_values=(numpy.nan,))

        # Now that we've padded, we can reshape without fear
        wav_data_2d = numpy.reshape(padded_wav_data_1d, (y,x), order='C')

    return wav_data_2d


def ukotoku_wav2tiff_pad_and_write(
        output_file,
        unpadded_wav_data_1d,
        source_shape,
        x,
        y):

        number_of_elements_in_wav = unpadded_wav_data_1d.size
        # As imageio.imwrite requires a 2D array, we have to convert the
        # one-dimensional unpadded_wav_data_1d array to 2D, but some 1D arrays
        # may not fit exactly in to a 2D array without leaving some
        # unfilled elements at the end.
        #
        # So running np.reshape() directly on the 1D array won't always work,
        # as reshape() requires the source and destination sizes must always
        # be the same, which they won't be if the source is smaller than
        # the destination (as some 1D arrays would necessarily have to be
        # in order to fit in to 2D).
        #
        # The solution is to first pad the 1D array with NANs to make
        # it fit exactly in to 2D, then reshape.
        #
        # Fortunately, the TIFF format has no problem with NANs, and
        # will "do the right thing" with them.  The GIMP image editor
        # also has no problem reading, editing, and writing TIFFs with NANs.

        # First we figure out the resolution that we need to make
        # the 2D array:
        if (x == 'guess') and (y == 'guess'):
            x, y = ukotoku_guess_image_resolution(number_of_elements_in_wav)
        elif (type(x) == type(3)) and (type(y) == type(3)):
            if x * y < unpadded_wav_data_1d.size:
                ukotoku_exiterr(f"Error: x * y resolution must be at least {unpadded_wav_data_1d.size}")
            else:
                pass
        else:
            # This should never happen
            ukotoku_exiterr("Error: Unexpected x and y image resolution types.")

        wav_data_2d = ukotoku_wav2tiff_get_wav_data_2d(
            unpadded_wav_data_1d, x, y, source_shape)

        imageio.imwrite(output_file, wav_data_2d)


def ukotoku_wav2tiff_validate_output_file(output_file):
    # Make sure the user specified an OUTPUT filename
    try:
        output_file
    except NameError:
        ukotoku_exiterr("You must specify an OUTPUT file")

    if output_file == '':
        ukotoku_exiterr("You must specify an OUTPUT file")

    # Make sure the OUTPUT filename has a valid extension
    match = re.search('\.([^.]+)$', output_file)
    if match:
        output_file_extension = match.group(1)
    else:
        ukotoku_exiterr("The INPUT filename must have an extension, such as .wav or .tiff")

    valid_audio_extensions = [
        'wav',
        ]

    valid_image_extensions = [
        'tiff',
        ]

    if   output_file_extension.casefold() in (f.casefold() for f in valid_audio_extensions):
        pass
    elif output_file_extension.casefold() in (f.casefold() for f in valid_image_extensions):
        pass
    else:
        valid_audio_extensions = ', '.join(valid_audio_extensions)
        valid_image_extensions = ', '.join(valid_image_extensions)
        message = "OUTPUT file extension must be one of: "
        message = message + valid_audio_extensions + valid_image_extensions
        ukotoku_exiterr(message)

    # Make sure OUTPUT does not exist
    output_file_exists = os.path.isfile(output_file)
    if output_file_exists:
        ukotoku_exiterr(f"OUTPUT file '{output_file}' already exists.")


def ukotoku_wav2tiff_validate_resolution(resolution):
    # Make sure the user specified a resolution or 'guess'
    try:
        resolution
    except NameError:
        ukotoku_exiterr("You must specify a resolution or 'guess'")

    if (resolution == '') or (resolution == None):
        ukotoku_exiterr("You must specify a resolution or 'guess'")


def ukotoku_get_input_file_type(input_file):
    # Make sure the input file type is allowed
    match = re.search('\.([^.]+)$', input_file)
    if match:
        input_file_extension = match.group(1)
    else:
        ukotoku_exiterr("The INPUT filename must have an extension, such as .wav or .tiff")

    valid_audio_extensions = [
        'wav',
        ]

    valid_image_extensions = [
        'tiff',
        ]

    if   input_file_extension.casefold() in (f.casefold() for f in valid_audio_extensions):
        return 'wav'
    elif input_file_extension.casefold() in (f.casefold() for f in valid_image_extensions):
        return 'tiff'
    else:
        valid_audio_extensions = ', '.join(valid_audio_extensions)
        valid_image_extensions = ', '.join(valid_image_extensions)
        message = "INPUT file extension must be one of: "
        message = message + valid_audio_extensions + valid_image_extensions
        ukotoku_exiterr(message)



if __name__ == '__main__':
    ukotoku()
