#!/usr/bin/python3.6
#
# Convert files from audio formats to image formats and back.
#
#
##############################################################################
#
# Copyright (C) 2020 - Sergey Goldgaber
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
##############################################################################

# For command line argument processing:
import click

# For writing TIFF images:
import imageio

# For reading WAV files:
import wave

# For converting 1-dimensional WAV data to 2-dimensional numpy arrays
# Note: 2-dimensional numpy arrays are the only kind imageio will accept
import numpy

# For the ceil function
import math

# Regexes
import re

# To find out what the path of this script is
from pathlib import Path

# To check if a file exists with os.path.isfile()
import os


@click.command()
@click.argument('input_file',  nargs=1, required=True, metavar='INPUT')
@click.argument('output_file', nargs=1, required=True, metavar='OUTPUT')
@click.option("--bits",        required=False, type=click.INT,    help="Output image bit depth.")
@click.option("--channels",    required=True,  type=click.INT,    help="Number of channels in image or audio file.")
@click.option("--resolution",  required=False, type=click.STRING, help="x, y image resolution", metavar="WIDTHxHEIGHT or 'guess'")
@click.option("--sampwidth",   required=False, type=click.INT,    help="Sample width for the audio file.")
@click.option("--samprate",    required=False, type=click.INT,    help="Sample rate for the audio file.")
@click.option("--signed/--unsigned", required=False, help="Output image bits signed or unsigned.")
@click.pass_context
def ukotoku(ctx, input_file, output_file, bits, channels, resolution, sampwidth, samprate, signed):
    ctx.ensure_object(dict)
    ctx.obj['bits']        = bits
    ctx.obj['channels']    = channels
    ctx.obj['input_file']  = input_file
    ctx.obj['output_file'] = output_file
    ctx.obj['resolution']  = resolution
    ctx.obj['samprate']    = samprate
    ctx.obj['sampwidth']   = sampwidth
    ctx.obj['signed']      = signed
    input_file_type = ukotoku_get_input_file_type(input_file)
    output_file_type = ukotoku_get_output_file_type(output_file)
    ctx.obj['output_file_type'] = output_file_type
    if input_file_type == 'wav':
        if output_file_type == 'jpg':
            if (bits == 8) and (signed == False):
                ukotoku_audio2image()
            else:
                ukotoku_exiterr("Only unsigned 8 bit is supported for JPEG output.")
        elif output_file_type == 'png':
            if (bits == 8) and (signed == False):
                ukotoku_audio2image()
            else:
                ukotoku_exiterr("Only unsigned 8 bit is supported for PNG output.")
        elif output_file_type == 'tiff':
            ukotoku_audio2image()
    elif input_file_type == 'tiff':
        if output_file_type == 'wav':
            ukotoku_image2wav()
        else:
            ukotoku_exiterr("Only WAV files are supported as output from TIFF files.")
    else:
        ukotoku_exiterr("Unexpected INPUT file type.")


# Exit after printing an error message to STDERR
def ukotoku_exiterr(message):
    ukotoku_printerr(message)
    exit(1)


# Expect image resolution in the form WIDTHxHEIGHT or 'guess'
def ukotoku_get_image_size_from_user(resolution):
    ukotoku_audio2image_validate_resolution(resolution)

    if resolution == 'guess':
        x = 'guess'
        y = 'guess'
    else:
        match = re.search('^(\d+)x(\d+)$', resolution)
        if match:
            x = int(match.group(1))
            y = int(match.group(2))
        else:
            ukotoku_exiterr("resolution must be in the form WIDTHxHEIGHT or 'guess'")
    return (x, y)


def ukotoku_get_output_file_type(output_file):
    # Make sure the output file type is allowed
    match = re.search('\.([^.]+)$', output_file)
    if match:
        output_file_extension = match.group(1)
    else:
        ukotoku_exiterr("The OUTPUT filename must have an extension, such as .wav or .tiff")

    valid_audio_extensions = [
        'wav',
        ]

    valid_image_extensions = [
        'jpg',
        'png',
        'tiff',
        ]

    if   output_file_extension.casefold() in (f.casefold() for f in valid_audio_extensions):
        return output_file_extension.lower()
    elif output_file_extension.casefold() in (f.casefold() for f in valid_image_extensions):
        return output_file_extension.lower()
    else:
        valid_audio_extensions = ', '.join(valid_audio_extensions)
        valid_image_extensions = ', '.join(valid_image_extensions)
        message = "OUTPUT file extension must be one of: "
        message = message + valid_audio_extensions + valid_image_extensions
        ukotoku_exiterr(message)



def ukotoku_get_raw_wav(input_file):
    # Read file to get buffer
    ifile   = wave.open(input_file)
    samples = ifile.getnframes()
    raw_wav = ifile.readframes(samples)
    return raw_wav


# Decide on image resolution.
#
# We could choose anything, but have decided on a square
# that should fit at least as many elements as are contained in the
# one-dimensional WAV array
def ukotoku_guess_image_resolution(number_of_elements_in_audio, channels):
    try:
        elements_remaining = number_of_elements_in_audio / channels
    except ZeroDivisionError:
        ukotoku_exiterr("You must have at least one channel.")
    else:
        # We do the following to make the minimum sized square that will
        # fit the data:
        x = math.ceil(math.sqrt(elements_remaining))
        y = x
        return (x,y)


# Print an error message to STDERR
def ukotoku_printerr(message):
    this_script = Path(__file__)
    message = f'{this_script}: Error: {message}'
    click.echo(message=message, err=True)


@click.pass_context
def ukotoku_image2wav(ctx):
    # Make sure OUTPUT does not exist
    output_file_exists = os.path.isfile(ctx.obj['output_file'])
    if output_file_exists:
        ukotoku_exiterr(f"OUTPUT file '{output_file}' already exists.")
    image_data = imageio.imread(ctx.obj['input_file'])

    # Change multidimensional image array to 1D
    image_data = image_data.reshape(image_data.size,order='C')

    wav_output_file = wave.open(ctx.obj['output_file'], 'w')
    wav_output_file.setnchannels(ctx.obj['channels'])
    wav_output_file.setsampwidth(ctx.obj['sampwidth'])
    wav_output_file.setframerate(ctx.obj['samprate'])

    wav_output_file.writeframesraw(image_data)


@click.pass_context
def ukotoku_audio2image(ctx):
    bits   = ctx.obj['bits']
    signed = ctx.obj['signed']
    x, y = ukotoku_get_image_size_from_user(ctx.obj['resolution'])

    raw_wav = ukotoku_get_raw_wav(ctx.obj['input_file'])

    # Convert raw WAV to a one-dimensional numpy array
    if   (bits ==  8) and (signed == False):
        unpadded_wav_data_1d = numpy.frombuffer(raw_wav, dtype=numpy.uint8)
    elif (bits == 16) and (signed == True):
        unpadded_wav_data_1d = numpy.frombuffer(raw_wav, dtype=numpy.int16)
    elif (bits == 16) and (signed == False):
        unpadded_wav_data_1d = numpy.frombuffer(raw_wav, dtype=numpy.uint16)
    else:
        ukotoku_exiterr(f"Unsupported combination of bits ({bits}) and signed ({signed})")

    print(f"unpadded_wav_data_1d.size = {unpadded_wav_data_1d.size}")
    source_shape = unpadded_wav_data_1d.shape
    if len(source_shape) == 1:
        ctx.obj['x']                = x
        ctx.obj['y']                = y
        ctx.obj['source_shape']     = source_shape
        ukotoku_audio2image_pad_and_write(unpadded_wav_data_1d)
    else:
        ukotoku_exiterr("Error: Unexpected WAV data format")


@click.pass_context
def ukotoku_audio2image_get_multidimensional_wav_data(ctx, unpadded_wav_data_1d):
    channels = ctx.obj['channels']
    source_shape = ctx.obj['source_shape']
    x = ctx.obj['x']
    y = ctx.obj['y']

    if x * y == unpadded_wav_data_1d.size:
        # No padding is necessary
        multidimensional_wav_data = numpy.reshape(unpadded_wav_data_1d, (channels, y,x), order='C')
    else:
        # Padding is necessary

        # Figure out how much to pad the source array to the right
        # to make it fit the destination array shape exactly
        right_padding_len = numpy.prod((x,y,channels)) - numpy.prod(source_shape)

        # We now have enough information to pad
        pad_width = (0,right_padding_len)
        padded_wav_data_1d = numpy.pad(unpadded_wav_data_1d,
                                        pad_width,
                                        mode='constant',
                                        constant_values=(numpy.nan,))

        # Now that we've padded, we can reshape without fear
        multidimensional_wav_data = numpy.reshape(padded_wav_data_1d, (y,x,channels), order='C')

    return multidimensional_wav_data


@click.pass_context
def ukotoku_audio2image_pad_and_write(ctx, unpadded_wav_data_1d):
    channels = ctx.obj['channels']
    x = ctx.obj['x']
    y = ctx.obj['y']

    number_of_elements_in_audio = unpadded_wav_data_1d.size
    # As imageio.imwrite requires a multidimensional array, we have to
    # convert the one-dimensional unpadded_wav_data_1d array to as many
    # dimensions as there are channels, but some 1D arrays may not fit
    # exactly in to a multidimensional array without leaving some unfilled
    # elements at the end.
    #
    # So running np.reshape() directly on the 1D array won't always work,
    # as reshape() requires the source and destination sizes must always
    # be the same, which they won't be if the source is smaller than the
    # destination (as some 1D arrays would necessarily have to be in order
    # to fit in to the required number of dimensions).
    #
    # The solution is to first pad the 1D array with NANs to make it fit
    # exactly in to the required number of dimensions, then reshape.
    #
    # Fortunately, the TIFF format has no problem with NANs, and will "do
    # the right thing" with them. The GIMP image editor also has no problem
    # reading, editing, and writing TIFFs with NANs.

    # First we figure out the resolution that we need to make the
    # multidimensional array:
    if (x == 'guess') and (y == 'guess'):
        x, y = ukotoku_guess_image_resolution(number_of_elements_in_audio, channels)
    elif (type(x) == type(3)) and (type(y) == type(3)):
        if x * y * channels < unpadded_wav_data_1d.size:
            ukotoku_exiterr(f"Error: x * y channels must be at least {unpadded_wav_data_1d.size}")
        else:
            pass
    else:
        # This should never happen
        ukotoku_exiterr("Error: Unexpected x and y image resolution types.")

    multidimensional_wav_data = ukotoku_audio2image_get_multidimensional_wav_data(
        unpadded_wav_data_1d)

    #multidimensional_wav_data = multidimensional_wav_data.reshape((3, -1)).T
    #multidimensional_wav_data = multidimensional_wav_data.reshape((3, -1,channels)).T
    #multidimensional_wav_data = multidimensional_wav_data.reshape((x, -1,channels))
    #imageio.imwrite(output_file, multidimensional_wav_data, format="PNG-PIL")
    if (ctx.obj['output_file_type'] == 'jpg'):
        imageio.imwrite(ctx.obj['output_file'], multidimensional_wav_data, format=None, quality=100)
    else:
        imageio.imwrite(ctx.obj['output_file'], multidimensional_wav_data)


def ukotoku_audio2image_validate_resolution(resolution):
    # Make sure the user specified a resolution or 'guess'
    try:
        resolution
    except NameError:
        ukotoku_exiterr("You must specify a resolution or 'guess'")

    if (resolution == '') or (resolution == None):
        ukotoku_exiterr("You must specify a resolution or 'guess'")


def ukotoku_get_input_file_type(input_file):
    # Make sure the input file type is allowed
    match = re.search('\.([^.]+)$', input_file)
    if match:
        input_file_extension = match.group(1)
    else:
        ukotoku_exiterr("The INPUT filename must have an extension, such as .wav or .tiff")

    valid_audio_extensions = [
        'wav',
        ]

    valid_image_extensions = [
        'jpg',
        'jpeg',
        'png',
        'tiff',
        ]

    if   input_file_extension.casefold() in (f.casefold() for f in valid_audio_extensions):
        return 'wav'
    elif input_file_extension.casefold() in (f.casefold() for f in valid_image_extensions):
        return 'tiff'
    else:
        valid_audio_extensions = ', '.join(valid_audio_extensions)
        valid_image_extensions = ', '.join(valid_image_extensions)
        message = "INPUT file extension must be one of: "
        message = message + valid_audio_extensions + valid_image_extensions
        ukotoku_exiterr(message)



if __name__ == '__main__':
    ukotoku()
